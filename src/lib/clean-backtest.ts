import type { OHLCData, Strategy, BacktestResult, Trade, EquityPoint } from '../types';
import { IndicatorEngine } from './indicators';
import { MetricsCalculator } from './metrics';

/**
 * –ß–∏—Å—Ç—ã–π –±—ç–∫—Ç–µ—Å—Ç —Ç–æ–ª—å–∫–æ –¥–ª—è IBS —Å—Ç—Ä–∞—Ç–µ–≥–∏–∏
 * –ù–∏–∫–∞–∫–∏—Ö –∫–æ–º–∏—Å—Å–∏–π, –ø—Ä–æ—Å–∫–∞–ª—å–∑—ã–≤–∞–Ω–∏–π, —Å—Ç–æ–ø-–ª–æ—Å—Å–æ–≤
 */
export class CleanBacktestEngine {
  private data: OHLCData[];
  private strategy: Strategy;
  private trades: Trade[] = [];
  private equity: EquityPoint[] = [];
  private currentCapital: number;
  private ibsValues: number[] = [];

  constructor(data: OHLCData[], strategy: Strategy) {
    this.data = data;
    this.strategy = strategy;
    this.currentCapital = strategy.riskManagement.initialCapital;
    
    // –†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ–º IBS –¥–ª—è –≤—Å–µ—Ö –±–∞—Ä–æ–≤ (–±–µ–∑ –∏—Å–∫–ª—é—á–µ–Ω–∏–π –Ω–∞ –ø—É—Å—Ç—ã—Ö –¥–∞–Ω–Ω—ã—Ö)
    this.ibsValues = data && data.length > 0 ? IndicatorEngine.calculateIBS(data) : [];
  }

  public runBacktest(): BacktestResult {
    console.log('üîß STRATEGY PARAMETERS:', this.strategy.parameters);
    // –ü—É—Å—Ç—ã–µ –¥–∞–Ω–Ω—ã–µ -> –ø—É—Å—Ç–æ–π —Ä–µ–∑—É–ª—å—Ç–∞—Ç –±–µ–∑ –æ—à–∏–±–æ–∫
    if (!this.data || this.data.length === 0) {
      return {
        trades: [],
        metrics: new MetricsCalculator([], [], this.strategy.riskManagement.initialCapital).calculateAllMetrics(),
        equity: [],
        chartData: [],
        insights: []
      };
    }
    
    let position: {
      entryDate: Date;
      entryPrice: number;
      quantity: number;
      entryIndex: number;
    } | null = null;

    const lowIBS = this.strategy.parameters.lowIBS || 0.1;
    const highIBS = this.strategy.parameters.highIBS || 0.75;
    const maxHoldDays = this.strategy.parameters.maxHoldDays || 30;
    const capitalUsage = this.strategy.riskManagement.capitalUsage || 100;

    // –ü—Ä–æ—Ö–æ–¥–∏–º –ø–æ –≤—Å–µ–º –±–∞—Ä–∞–º (–∫—Ä–æ–º–µ –ø–æ—Å–ª–µ–¥–Ω–µ–≥–æ, —Ç–∞–∫ –∫–∞–∫ –Ω—É–∂–µ–Ω —Å–ª–µ–¥—É—é—â–∏–π –¥–µ–Ω—å –¥–ª—è –≤—Ö–æ–¥–∞)
    for (let i = 0; i < this.data.length - 1; i++) {
      const bar = this.data[i];
      const nextBar = this.data[i + 1];
      const ibs = this.ibsValues[i];

      if (isNaN(ibs)) continue; // –ü—Ä–æ–ø—É—Å–∫–∞–µ–º –Ω–µ–≤–∞–ª–∏–¥–Ω—ã–µ IBS

      // –ï—Å–ª–∏ –Ω–µ—Ç –ø–æ–∑–∏—Ü–∏–∏ - –ø—Ä–æ–≤–µ—Ä—è–µ–º –≤—Ö–æ–¥
      if (!position) {
        if (ibs < lowIBS) {
          // –°–ò–ì–ù–ê–õ –í–•–û–î–ê: IBS —Ç–µ–∫—É—â–µ–≥–æ –¥–Ω—è < lowIBS
          // –ü–û–ö–£–ü–ö–ê: –ø–æ —Ü–µ–Ω–µ –æ—Ç–∫—Ä—ã—Ç–∏—è —Å–ª–µ–¥—É—é—â–µ–≥–æ –¥–Ω—è
          const investmentAmount = (this.currentCapital * capitalUsage) / 100;
          const quantity = Math.floor(investmentAmount / nextBar.open);
          
          if (quantity > 0) {
            const totalCost = quantity * nextBar.open;
            
            position = {
              entryDate: nextBar.date, // –î–∞—Ç–∞ –ø–æ–∫—É–ø–∫–∏ = —Å–ª–µ–¥—É—é—â–∏–π –¥–µ–Ω—å
              entryPrice: nextBar.open, // –¶–µ–Ω–∞ –ø–æ–∫—É–ø–∫–∏ = –æ—Ç–∫—Ä—ã—Ç–∏–µ —Å–ª–µ–¥—É—é—â–µ–≥–æ –¥–Ω—è
              quantity: quantity,
              entryIndex: i + 1 // –ò–Ω–¥–µ–∫—Å —Å–ª–µ–¥—É—é—â–µ–≥–æ –¥–Ω—è
            };
            
            this.currentCapital -= totalCost;
            console.log(`üü¢ ENTRY SIGNAL: IBS=${ibs.toFixed(3)} < ${lowIBS} on ${bar.date.toISOString().split('T')[0]}`);
            console.log(`üü¢ ENTRY EXECUTION: bought ${quantity} shares at $${nextBar.open.toFixed(2)} on ${nextBar.date.toISOString().split('T')[0]}`);
          }
        }
      } 
      // –ï—Å–ª–∏ –µ—Å—Ç—å –ø–æ–∑–∏—Ü–∏—è - –ø—Ä–æ–≤–µ—Ä—è–µ–º –≤—ã—Ö–æ–¥ (—Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ —ç—Ç–æ –Ω–µ –¥–µ–Ω—å –≤—Ö–æ–¥–∞)
      else if (i + 1 > position.entryIndex) {
        let shouldExit = false;
        let exitReason = '';

        // –ü—Ä–æ–≤–µ—Ä—è–µ–º IBS —É—Å–ª–æ–≤–∏–µ –≤—ã—Ö–æ–¥–∞
        if (ibs > highIBS) {
          shouldExit = true;
          exitReason = 'ibs_signal';
        }
        // –ü—Ä–æ–≤–µ—Ä—è–µ–º –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–µ –≤—Ä–µ–º—è —É–¥–µ—Ä–∂–∞–Ω–∏—è
        else {
          const daysDiff = Math.floor((bar.date.getTime() - position.entryDate.getTime()) / (1000 * 60 * 60 * 24));
          if (daysDiff >= maxHoldDays) {
            shouldExit = true;
            exitReason = 'max_hold_days';
          }
        }

        if (shouldExit) {
          // –í–´–•–û–î: –ø—Ä–æ–¥–∞–µ–º –≤—Å–µ –∞–∫—Ü–∏–∏ –ø–æ —Ü–µ–Ω–µ –∑–∞–∫—Ä—ã—Ç–∏—è
          const exitPrice = bar.close;
          const grossProceeds = position.quantity * exitPrice;
          const grossCost = position.quantity * position.entryPrice;
          const pnl = grossProceeds - grossCost;
          const pnlPercent = (pnl / grossCost) * 100;
          const duration = Math.floor((bar.date.getTime() - position.entryDate.getTime()) / (1000 * 60 * 60 * 24));

          // –°–æ–∑–¥–∞–µ–º —Å–¥–µ–ª–∫—É
          const trade: Trade = {
            id: `trade-${this.trades.length}`,
            entryDate: position.entryDate,
            exitDate: bar.date,
            entryPrice: position.entryPrice,
            exitPrice: exitPrice,
            quantity: position.quantity,
            pnl: pnl,
            pnlPercent: pnlPercent,
            duration: duration,
            exitReason: exitReason,
            context: {
              marketConditions: 'normal',
              indicatorValues: { IBS: ibs },
              volatility: 0,
              trend: 'sideways',
              initialInvestment: grossCost,
              currentCapitalAfterExit: 0 // –û–±–Ω–æ–≤–∏–º –Ω–∏–∂–µ
            }
          };

          this.trades.push(trade);
          this.currentCapital += grossProceeds;
          
          // –û–±–Ω–æ–≤–ª—è–µ–º –∫–∞–ø–∏—Ç–∞–ª –≤ –∫–æ–Ω—Ç–µ–∫—Å—Ç–µ —Å–¥–µ–ª–∫–∏
          trade.context!.currentCapitalAfterExit = this.currentCapital;

          console.log(`üî¥ EXIT: IBS=${ibs.toFixed(3)}, ${exitReason}, P&L=$${pnl.toFixed(2)}, Duration=${duration} days`);
          
          position = null;
        }
      }

      // –û–±–Ω–æ–≤–ª—è–µ–º equity curve
      let totalValue = this.currentCapital;
      if (position) {
        totalValue += position.quantity * bar.close;
      }

      // –†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ–º drawdown
      const peakValue = this.equity.length > 0 
        ? Math.max(...this.equity.map(e => e.value), totalValue)
        : totalValue;
      const drawdown = peakValue > 0 ? ((peakValue - totalValue) / peakValue) * 100 : 0;

      this.equity.push({
        date: bar.date,
        value: totalValue,
        drawdown: drawdown
      });
    }

    // –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –ø–æ—Å–ª–µ–¥–Ω–∏–π –±–∞—Ä –æ—Ç–¥–µ–ª—å–Ω–æ (—Ç–æ–ª—å–∫–æ –¥–ª—è equity –∏ –≤—ã—Ö–æ–¥–∞)
    const lastBar = this.data[this.data.length - 1];
    const lastIBS = this.ibsValues[this.data.length - 1];
    
    if (position) {
      // –ü—Ä–æ–≤–µ—Ä—è–µ–º –≤—ã—Ö–æ–¥ –Ω–∞ –ø–æ—Å–ª–µ–¥–Ω–µ–º –±–∞—Ä–µ
      let shouldExit = false;
      let exitReason = '';

      if (!isNaN(lastIBS) && lastIBS > highIBS) {
        shouldExit = true;
        exitReason = 'ibs_signal';
      } else {
        const daysDiff = Math.floor((lastBar.date.getTime() - position.entryDate.getTime()) / (1000 * 60 * 60 * 24));
        if (daysDiff >= maxHoldDays) {
          shouldExit = true;
          exitReason = 'max_hold_days';
        } else {
          shouldExit = true;
          exitReason = 'end_of_data';
        }
      }

      if (shouldExit) {
        const exitPrice = lastBar.close;
        const grossProceeds = position.quantity * exitPrice;
        const grossCost = position.quantity * position.entryPrice;
        const pnl = grossProceeds - grossCost;
        const pnlPercent = (pnl / grossCost) * 100;
        const duration = Math.floor((lastBar.date.getTime() - position.entryDate.getTime()) / (1000 * 60 * 60 * 24));

        const trade: Trade = {
          id: `trade-${this.trades.length}`,
          entryDate: position.entryDate,
          exitDate: lastBar.date,
          entryPrice: position.entryPrice,
          exitPrice: exitPrice,
          quantity: position.quantity,
          pnl: pnl,
          pnlPercent: pnlPercent,
          duration: duration,
          exitReason: exitReason,
          context: {
            marketConditions: 'normal',
            indicatorValues: { IBS: lastIBS },
            volatility: 0,
            trend: 'sideways',
            initialInvestment: grossCost,
            currentCapitalAfterExit: this.currentCapital + grossProceeds
          }
        };

        this.trades.push(trade);
        this.currentCapital += grossProceeds;
        position = null;
      }
    }

    // –î–æ–±–∞–≤–ª—è–µ–º –ø–æ—Å–ª–µ–¥–Ω–∏–π equity point
    let finalValue = this.currentCapital;
    if (position) {
      finalValue += position.quantity * lastBar.close;
    }

    const finalPeakValue = this.equity.length > 0 
      ? Math.max(...this.equity.map(e => e.value), finalValue)
      : finalValue;
    const finalDrawdown = finalPeakValue > 0 ? ((finalPeakValue - finalValue) / finalPeakValue) * 100 : 0;

    this.equity.push({
      date: lastBar.date,
      value: finalValue,
      drawdown: finalDrawdown
    });



    // –†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ–º –º–µ—Ç—Ä–∏–∫–∏
    const metricsCalculator = new MetricsCalculator(
      this.trades,
      this.equity,
      this.strategy.riskManagement.initialCapital
    );

    const metrics = metricsCalculator.calculateAllMetrics();

    console.log(`‚úÖ Backtest completed: ${this.trades.length} trades, Final capital: $${this.currentCapital.toFixed(2)}`);

    return {
      trades: this.trades,
      metrics: metrics,
      equity: this.equity,
      chartData: [],
      insights: []
    };
  }
}