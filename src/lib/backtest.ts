import type {
  OHLCData,
  Strategy,
  BacktestResult,
  Trade,
  PerformanceMetrics,
  EquityPoint,
  Condition
} from '../types';
import { IndicatorEngine } from './indicators';
import { MetricsCalculator } from './metrics';
// import { InsightsEngine } from './insights'; // Removed for simplification

/**
 * Position represents an open trade
 */
interface Position {
  id: string;
  entryDate: Date;
  entryPrice: number;
  quantity: number;
  entryIndex: number;
  stopLoss?: number;
  takeProfit?: number;
  maxHoldDays?: number;
}

/**
 * Signal represents entry/exit signals generated by strategy conditions
 */
interface Signal {
  type: 'entry' | 'exit';
  date: Date;
  price: number;
  index: number;
  reason?: string;
}

/**
 * BacktestEngine - Core backtesting algorithm that processes OHLC data chronologically
 */
export class BacktestEngine {
  private data: OHLCData[];
  private strategy: Strategy;
  private indicators: Map<string, number[]> = new Map();
  private signals: Signal[] = [];
  private trades: Trade[] = [];
  private equity: EquityPoint[] = [];
  private currentCapital: number;
  private currentPosition: Position | null = null;

  constructor(data: OHLCData[], strategy: Strategy) {
    this.data = data;
    this.strategy = strategy;
    this.currentCapital = strategy.riskManagement.initialCapital;
    
    this.validateInputs();
    this.calculateIndicators();
  }

  /**
   * Run the complete backtest
   */
  public runBacktest(): BacktestResult {
    this.resetState();
    this.processDataChronologically();
    this.closeOpenPosition();
    this.logIBSStatistics();
    
    const metrics = this.calculatePerformanceMetrics();
    
    // Create simplified result
    const result: BacktestResult = {
      trades: this.trades,
      metrics,
      equity: this.equity,
      chartData: this.generateChartData(),
      insights: []
    };
    
    return result;
  }

  /**
   * Reset backtest state
   */
  private resetState(): void {
    this.signals = [];
    this.trades = [];
    this.equity = [];
    this.currentCapital = this.strategy.riskManagement.initialCapital;
    this.currentPosition = null;
  }

  /**
   * Process OHLC data chronologically
   */
  private processDataChronologically(): void {
    for (let i = 0; i < this.data.length; i++) {
      const bar = this.data[i];
      
      // Check for exit signals first (if we have a position)
      if (this.currentPosition) {
        this.checkExitConditions(i, bar);
      }
      
      // Check for entry signals (if we don't have a position)
      if (!this.currentPosition) {
        this.checkEntryConditions(i, bar);
      }
      
      // Update equity curve
      this.updateEquityCurve(i, bar);
    }
  }

  /**
   * Check entry conditions for the current bar
   */
  private checkEntryConditions(index: number, bar: OHLCData): void {
    const ibsValue = this.indicators.get('IBS')?.[index];
    const lowThreshold = this.strategy.parameters.lowIBS || 0.1;
    
    if (this.evaluateConditions(this.strategy.entryConditions, index)) {
      console.log(`üü¢ ENTRY SIGNAL: IBS=${ibsValue?.toFixed(3)} < ${lowThreshold} at ${bar.date.toISOString().split('T')[0]}`);
      this.enterPosition(index, bar);
    }
  }

  /**
   * Check exit conditions for the current bar
   */
  private checkExitConditions(index: number, bar: OHLCData): void {
    if (!this.currentPosition) return;

    let exitReason: string | null = null;
    let exitPrice = bar.close;

    // –î–ª—è IBS —Å—Ç—Ä–∞—Ç–µ–≥–∏–∏: IBS + maxHoldDays, –Ω–æ —Ç–∞–∫–∂–µ —É—á–∏—Ç—ã–≤–∞–µ–º –æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω—ã–µ SL/TP –µ—Å–ª–∏ –≤–∫–ª—é—á–µ–Ω—ã
    if (this.strategy.id === 'ibs-mean-reversion' || this.strategy.type === 'ibs-mean-reversion') {
      // –ü—Ä–æ–≤–µ—Ä—è–µ–º Stop Loss / Take Profit –µ—Å–ª–∏ –≤–∫–ª—é—á–µ–Ω—ã
      const useSL = !!this.strategy.riskManagement.useStopLoss;
      const useTP = !!this.strategy.riskManagement.useTakeProfit;
      if (useSL && this.currentPosition.stopLoss && bar.low <= this.currentPosition.stopLoss) {
        exitReason = 'stop_loss';
        exitPrice = this.currentPosition.stopLoss;
      } else if (useTP && this.currentPosition.takeProfit && bar.high >= this.currentPosition.takeProfit) {
        exitReason = 'take_profit';
        exitPrice = this.currentPosition.takeProfit;
      }
      // 1. –ü—Ä–æ–≤–µ—Ä—è–µ–º IBS —É—Å–ª–æ–≤–∏–µ –≤—ã—Ö–æ–¥–∞
      if (!exitReason && this.evaluateConditions(this.strategy.exitConditions, index)) {
        exitReason = 'ibs_signal';
      }
      // 2. –ü—Ä–æ–≤–µ—Ä—è–µ–º –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–µ –≤—Ä–µ–º—è —É–¥–µ—Ä–∂–∞–Ω–∏—è
      else if (!exitReason && this.currentPosition.maxHoldDays) {
        const daysDiff = Math.floor((bar.date.getTime() - this.currentPosition.entryDate.getTime()) / (1000 * 60 * 60 * 24));
        if (daysDiff >= this.currentPosition.maxHoldDays) {
          exitReason = 'max_hold_days';
        }
      }
    } else {
      // –î–ª—è –¥—Ä—É–≥–∏—Ö —Å—Ç—Ä–∞—Ç–µ–≥–∏–π - –ø–æ–ª–Ω–∞—è –ª–æ–≥–∏–∫–∞
      if (this.evaluateConditions(this.strategy.exitConditions, index)) {
        exitReason = 'signal';
      }
      else if (this.currentPosition.stopLoss && bar.low <= this.currentPosition.stopLoss) {
        exitReason = 'stop_loss';
        exitPrice = this.currentPosition.stopLoss;
      }
      else if (this.currentPosition.takeProfit && bar.high >= this.currentPosition.takeProfit) {
        exitReason = 'take_profit';
        exitPrice = this.currentPosition.takeProfit;
      }
      else if (this.currentPosition.maxHoldDays) {
        const daysDiff = Math.floor((bar.date.getTime() - this.currentPosition.entryDate.getTime()) / (1000 * 60 * 60 * 24));
        if (daysDiff >= this.currentPosition.maxHoldDays) {
          exitReason = 'max_hold_days';
        }
      }
    }

    if (exitReason) {
      this.exitPosition(index, bar, exitPrice, exitReason);
    }
  }

  /**
   * Enter a new position
   */
  private enterPosition(index: number, bar: OHLCData): void {
    const entryPrice = this.calculateEntryPrice(bar);
    const quantity = this.calculatePositionSize(entryPrice);
    
    if (quantity <= 0) return;

    // Apply slippage (–æ—Ç–∫–ª—é—á–µ–Ω–æ –¥–ª—è IBS —Å—Ç—Ä–∞—Ç–µ–≥–∏–∏)
    const slippageAdjustedPrice = (this.strategy.id === 'ibs-mean-reversion' || this.strategy.type === 'ibs-mean-reversion') 
      ? entryPrice 
      : entryPrice * (1 + this.strategy.riskManagement.slippage);
    
    // Calculate commission on entry
    const entryCommission = this.calculateCommission(quantity * slippageAdjustedPrice);
    
    // Check if we have enough capital
    const totalCost = (quantity * slippageAdjustedPrice) + entryCommission;
    if (totalCost > this.currentCapital) {
      console.log(`Not enough capital: need $${totalCost.toFixed(2)}, have $${this.currentCapital.toFixed(2)}`);
      return; // Not enough capital
    }

    // Create position
    this.currentPosition = {
      id: `trade-${Date.now()}-${index}`,
      entryDate: bar.date,
      entryPrice: slippageAdjustedPrice,
      quantity,
      entryIndex: index,
      // –î–ª—è IBS —Å—Ç—Ä–∞—Ç–µ–≥–∏–∏ –∏—Å–ø–æ–ª—å–∑—É–µ–º SL/TP —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –≤–∫–ª—é—á–µ–Ω—ã —Ñ–ª–∞–≥–∏
      stopLoss: (this.strategy.id === 'ibs-mean-reversion' || this.strategy.type === 'ibs-mean-reversion')
        ? (this.strategy.riskManagement.useStopLoss ? this.calculateStopLoss(slippageAdjustedPrice) : undefined)
        : this.calculateStopLoss(slippageAdjustedPrice),
      takeProfit: (this.strategy.id === 'ibs-mean-reversion' || this.strategy.type === 'ibs-mean-reversion')
        ? (this.strategy.riskManagement.useTakeProfit ? this.calculateTakeProfit(slippageAdjustedPrice) : undefined)
        : this.calculateTakeProfit(slippageAdjustedPrice),
      maxHoldDays: this.strategy.parameters.maxHoldDays || this.strategy.riskManagement.maxHoldDays || 30
    };

    // Update capital - subtract the total cost
    this.currentCapital -= totalCost;
    
    console.log(`üü¢ ENTERED POSITION: ${quantity} shares at $${slippageAdjustedPrice.toFixed(2)}, date: ${bar.date.toISOString().split('T')[0]}`);
    console.log(`üìä Position details: maxHoldDays=${this.currentPosition.maxHoldDays}, stopLoss=$${this.currentPosition.stopLoss?.toFixed(2)}, takeProfit=$${this.currentPosition.takeProfit?.toFixed(2)}`);

    // Record signal
    this.signals.push({
      type: 'entry',
      date: bar.date,
      price: slippageAdjustedPrice,
      index,
      reason: 'strategy_signal'
    });
  }

  /**
   * Exit current position
   */
  private exitPosition(index: number, bar: OHLCData, exitPrice: number, exitReason: string): void {
    if (!this.currentPosition) return;

    // Apply slippage (–æ—Ç–∫–ª—é—á–µ–Ω–æ –¥–ª—è IBS —Å—Ç—Ä–∞—Ç–µ–≥–∏–∏)
    const slippageAdjustedPrice = (this.strategy.id === 'ibs-mean-reversion' || this.strategy.type === 'ibs-mean-reversion') 
      ? exitPrice 
      : exitPrice * (1 - this.strategy.riskManagement.slippage);
    
    // Calculate commission on exit
    const exitCommission = this.calculateCommission(this.currentPosition.quantity * slippageAdjustedPrice);
    
    // Calculate entry commission (should have been calculated at entry)
    const entryCommission = this.calculateCommission(this.currentPosition.quantity * this.currentPosition.entryPrice);
    
    // Calculate P&L correctly
    const grossProceeds = this.currentPosition.quantity * slippageAdjustedPrice;
    const grossCost = this.currentPosition.quantity * this.currentPosition.entryPrice;
    const totalCommissions = entryCommission + exitCommission;
    
    // Net P&L = (Exit Value - Entry Value) - Total Commissions
    const pnl = (grossProceeds - grossCost) - totalCommissions;
    
    // Percentage return based on initial investment
    const initialInvestment = grossCost + entryCommission;
    const pnlPercent = (pnl / initialInvestment) * 100;

    // Calculate trade duration
    const duration = Math.floor((bar.date.getTime() - this.currentPosition.entryDate.getTime()) / (1000 * 60 * 60 * 24));
    
    // Debug: –ø—Ä–æ–≤–µ—Ä—è–µ–º –ø—Ä–∏—á–∏–Ω—É –≤—ã—Ö–æ–¥–∞ –∏ –∏–Ω–≤–µ—Å—Ç–∏—Ü–∏–∏
    console.log(`üîö TRADE: ${duration} days, Reason: ${exitReason}, Investment: $${initialInvestment.toFixed(2)}, P&L: $${pnl.toFixed(2)}, Capital before: $${this.currentCapital.toFixed(2)}`);

    // Create trade record with detailed information
    const trade: Trade = {
      id: this.currentPosition.id,
      entryDate: this.currentPosition.entryDate,
      exitDate: bar.date,
      entryPrice: this.currentPosition.entryPrice,
      exitPrice: slippageAdjustedPrice,
      quantity: this.currentPosition.quantity,
      pnl,
      pnlPercent,
      duration,
      exitReason,
      context: {
        marketConditions: 'normal',
        indicatorValues: this.getIndicatorValues(index),
        volatility: this.calculateVolatility(index),
        trend: this.calculateTrend(index),
        // Add detailed calculation info for debugging
        grossProceeds,
        grossCost,
        totalCommissions,
        initialInvestment,
        stopLoss: this.currentPosition.stopLoss,
        takeProfit: this.currentPosition.takeProfit
      }
    };

    this.trades.push(trade);
    


    // Update capital correctly
    this.currentCapital += grossProceeds - exitCommission;
    
    console.log(`üí∞ Capital updated: $${this.currentCapital.toFixed(2)} (was $${(this.currentCapital - grossProceeds + exitCommission).toFixed(2)})`);
    
    // Add current capital to trade context
    trade.context!.currentCapitalAfterExit = this.currentCapital;

    // Record signal
    this.signals.push({
      type: 'exit',
      date: bar.date,
      price: slippageAdjustedPrice,
      index,
      reason: exitReason
    });

    // Clear position
    this.currentPosition = null;
  }

  /**
   * Close any open position at the end of data
   */
  private closeOpenPosition(): void {
    if (this.currentPosition && this.data.length > 0) {
      const lastBar = this.data[this.data.length - 1];
      this.exitPosition(this.data.length - 1, lastBar, lastBar.close, 'end_of_data');
    }
  }

  /**
   * Calculate position size based on strategy settings
   */
  private calculatePositionSize(price: number): number {
    const { riskManagement } = this.strategy;
    
    // –ò—Å–ø–æ–ª—å–∑—É–µ–º capitalUsage –∫–∞–∫ –ø—Ä–æ—Ü–µ–Ω—Ç –¥–µ–ø–æ–∑–∏—Ç–∞ –¥–ª—è —Å–¥–µ–ª–∫–∏
    const capitalUsagePercent = riskManagement.capitalUsage || 100;
    const investmentAmount = (this.currentCapital * capitalUsagePercent) / 100;
    const quantity = Math.floor(investmentAmount / price);
    
    console.log(`üìä Position size: ${quantity} shares at $${price.toFixed(2)}, using $${(quantity * price).toFixed(2)} (${capitalUsagePercent}% of $${this.currentCapital.toFixed(2)})`);
    
    return quantity;
  }

  /**
   * Calculate commission based on strategy settings
   */
  private calculateCommission(tradeValue: number): number {
    const { commission } = this.strategy.riskManagement;
    
    switch (commission.type) {
      case 'fixed':
        return commission.fixed || 0;
      
      case 'percentage':
        return tradeValue * (commission.percentage || 0);
      
      case 'combined':
        const fixedPart = commission.fixed || 0;
        const percentagePart = tradeValue * (commission.percentage || 0);
        return fixedPart + percentagePart;
      
      default:
        return 0;
    }
  }

  /**
   * Calculate stop loss price
   */
  private calculateStopLoss(entryPrice: number): number | undefined {
    const { stopLoss } = this.strategy.riskManagement;
    if (!stopLoss) return undefined;
    
    // Stop loss should ALWAYS be below entry price for long positions
    return entryPrice * (1 - Math.abs(stopLoss) / 100);
  }

  /**
   * Calculate take profit price
   */
  private calculateTakeProfit(entryPrice: number): number | undefined {
    const { takeProfit } = this.strategy.riskManagement;
    if (!takeProfit) return undefined;
    
    // Take profit should ALWAYS be above entry price for long positions
    return entryPrice * (1 + Math.abs(takeProfit) / 100);
  }

  /**
   * Calculate entry price (could be open, close, or other logic)
   */
  private calculateEntryPrice(bar: OHLCData): number {
    // For simplicity, use the close price
    // In a more sophisticated system, this could be configurable
    return bar.close;
  }

  /**
   * Evaluate a set of conditions for the current bar
   */
  private evaluateConditions(conditions: Condition[], index: number): boolean {
    if (conditions.length === 0) return false;
    
    // For now, use AND logic (all conditions must be true)
    // In a more sophisticated system, this could be configurable
    return conditions.every(condition => this.evaluateCondition(condition, index));
  }

  /**
   * Evaluate a single condition
   */
  private evaluateCondition(condition: Condition, index: number): boolean {
    const bar = this.data[index];
    
    switch (condition.type) {
      case 'indicator':
        return this.evaluateIndicatorCondition(condition, index);
      
      case 'price':
        return this.evaluatePriceCondition(condition, index, bar);
      
      case 'time':
        // Time-based conditions not implemented in this task
        return false;
      
      default:
        return false;
    }
  }

  /**
   * Evaluate indicator-based condition
   */
  private evaluateIndicatorCondition(condition: Condition, index: number): boolean {
    if (!condition.indicator) return false;
    
    const indicatorKey = this.getIndicatorKey(condition.indicator, condition);
    const indicatorValues = this.indicators.get(indicatorKey);
    
    if (!indicatorValues || index >= indicatorValues.length) {
      console.log(`No indicator values for ${indicatorKey} at index ${index}`);
      return false;
    }
    
    const currentValue = indicatorValues[index];
    if (isNaN(currentValue)) {
      console.log(`NaN value for ${indicatorKey} at index ${index}`);
      return false;
    }
    
    // –ò—Å–ø–æ–ª—å–∑—É–µ–º –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –∏–∑ —Å—Ç—Ä–∞—Ç–µ–≥–∏–∏ –¥–ª—è IBS —É—Å–ª–æ–≤–∏–π
    let conditionValue = condition.value;
    if (condition.indicator === 'IBS') {
      if (condition.operator === '<') {
        // –£—Å–ª–æ–≤–∏–µ –≤—Ö–æ–¥–∞ - –∏—Å–ø–æ–ª—å–∑—É–µ–º lowIBS –∏–∑ –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤
        conditionValue = this.strategy.parameters.lowIBS || 0.1;
      } else if (condition.operator === '>') {
        // –£—Å–ª–æ–≤–∏–µ –≤—ã—Ö–æ–¥–∞ - –∏—Å–ø–æ–ª—å–∑—É–µ–º highIBS –∏–∑ –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤
        conditionValue = this.strategy.parameters.highIBS || 0.75;
      }
    }
    
    const result = this.evaluateOperator(condition.operator, currentValue, conditionValue, indicatorValues, index);
    
    // Debug logging for IBS conditions (only for exits)
    if (condition.indicator === 'IBS' && condition.operator === '>' && result) {
      console.log(`IBS EXIT condition met: ${currentValue.toFixed(3)} > ${conditionValue} at index ${index}`);
    }
    
    return result;
  }
  
  private evaluateOperator(operator: string, currentValue: number, conditionValue: any, indicatorValues: number[], index: number): boolean {
    switch (operator) {
      case '>':
        return typeof conditionValue === 'number' && currentValue > conditionValue;
      
      case '<':
        return typeof conditionValue === 'number' && currentValue < conditionValue;
      
      case '=':
        return typeof conditionValue === 'number' && Math.abs(currentValue - conditionValue) < 0.0001;
      
      case 'crossover':
        return this.evaluateCrossover(indicatorValues, conditionValue, index, true);
      
      case 'crossunder':
        return this.evaluateCrossover(indicatorValues, conditionValue, index, false);
      
      default:
        return false;
    }
  }

  /**
   * Evaluate price-based condition
   */
  private evaluatePriceCondition(condition: Condition, _index: number, bar: OHLCData): boolean {
    const price = bar.close; // Use close price for simplicity
    
    if (condition.value === 'dynamic') {
      // Dynamic comparison (e.g., price vs moving average)
      // This would need more context about what to compare against
      return false;
    }
    
    if (typeof condition.value !== 'number') return false;
    
    switch (condition.operator) {
      case '>':
        return price > condition.value;
      
      case '<':
        return price < condition.value;
      
      case '=':
        return Math.abs(price - condition.value) < 0.01; // Allow small tolerance
      
      default:
        return false;
    }
  }

  /**
   * Evaluate crossover/crossunder conditions
   */
  private evaluateCrossover(series: number[], threshold: number | 'dynamic', index: number, isAbove: boolean): boolean {
    if (index === 0 || typeof threshold !== 'number') return false;
    
    const currentValue = series[index];
    const previousValue = series[index - 1];
    
    if (isNaN(currentValue) || isNaN(previousValue)) return false;
    
    if (isAbove) {
      // Crossover: previous <= threshold and current > threshold
      return previousValue <= threshold && currentValue > threshold;
    } else {
      // Crossunder: previous >= threshold and current < threshold
      return previousValue >= threshold && currentValue < threshold;
    }
  }

  /**
   * Update equity curve
   */
  private updateEquityCurve(_index: number, bar: OHLCData): void {
    let totalValue = this.currentCapital;
    
    // Add value of current position if any
    if (this.currentPosition) {
      const currentPrice = bar.close;
      const positionValue = this.currentPosition.quantity * currentPrice;
      totalValue += positionValue;
      
      // Debug: –ø–æ–∫–∞–∑—ã–≤–∞–µ–º —Ä–∞—Å—á–µ—Ç equity
      console.log(`üìà Equity: Cash=$${this.currentCapital.toFixed(2)} + Position=$${positionValue.toFixed(2)} = Total=$${totalValue.toFixed(2)}`);
    }
    
    // Calculate drawdown
    const peakValue = this.equity.length > 0 
      ? Math.max(...this.equity.map(e => e.value), totalValue)
      : totalValue;
    
    const drawdown = peakValue > 0 ? ((peakValue - totalValue) / peakValue) * 100 : 0;
    
    this.equity.push({
      date: bar.date,
      value: totalValue,
      drawdown
    });
  }



  /**
   * Calculate all required indicators
   */
  private calculateIndicators(): void {
    const closePrices = this.data.map(bar => bar.close);
    
    // Calculate indicators based on strategy conditions
    const allConditions = [...this.strategy.entryConditions, ...this.strategy.exitConditions];
    
    console.log('üîß STRATEGY PARAMETERS:', this.strategy.parameters);
    
    allConditions.forEach(condition => {
      if (condition.type === 'indicator' && condition.indicator) {
        const key = this.getIndicatorKey(condition.indicator, condition);
        
        if (!this.indicators.has(key)) {
          const values = this.calculateIndicatorValues(condition.indicator, condition);
          this.indicators.set(key, values);
          console.log(`Calculated ${key}: ${values.length} values`);
        }
      }
    });
    
    // Always calculate basic indicators for context (only if we have enough data)
    if (this.data.length >= 20 && !this.indicators.has('SMA_20')) {
      this.indicators.set('SMA_20', IndicatorEngine.calculateSMA(closePrices, 20));
    }
    if (this.data.length >= 15 && !this.indicators.has('RSI_14')) {
      this.indicators.set('RSI_14', IndicatorEngine.calculateRSI(closePrices, 14));
    }
    if (!this.indicators.has('IBS')) {
      this.indicators.set('IBS', IndicatorEngine.calculateIBS(this.data));
    }
  }

  /**
   * Calculate indicator values based on type and parameters
   */
  private calculateIndicatorValues(indicatorType: string, condition: Condition): number[] {
    const closePrices = this.data.map(bar => bar.close);
    
    switch (indicatorType) {
      case 'SMA':
        const smaPeriod = this.getIndicatorPeriod(condition, 20);
        if (smaPeriod > this.data.length) {
          return new Array(this.data.length).fill(NaN);
        }
        return IndicatorEngine.calculateSMA(closePrices, smaPeriod);
      
      case 'EMA':
        const emaPeriod = this.getIndicatorPeriod(condition, 20);
        if (emaPeriod > this.data.length) {
          return new Array(this.data.length).fill(NaN);
        }
        return IndicatorEngine.calculateEMA(closePrices, emaPeriod);
      
      case 'RSI':
        const rsiPeriod = this.getIndicatorPeriod(condition, 14);
        if (rsiPeriod + 1 > this.data.length) {
          return new Array(this.data.length).fill(NaN);
        }
        return IndicatorEngine.calculateRSI(closePrices, rsiPeriod);
      
      case 'IBS':
        return IndicatorEngine.calculateIBS(this.data);
      
      default:
        return new Array(this.data.length).fill(NaN);
    }
  }

  /**
   * Get indicator period from strategy parameters or use default
   */
  private getIndicatorPeriod(condition: Condition, defaultPeriod: number): number {
    // Try to get period from strategy parameters
    const parameterName = `${condition.indicator?.toLowerCase()}Period`;
    const period = this.strategy.parameters[parameterName];
    
    if (typeof period === 'number' && period > 0) {
      return period;
    }
    
    return defaultPeriod;
  }

  /**
   * Generate unique key for indicator caching
   */
  private getIndicatorKey(indicatorType: string, condition: Condition): string {
    const period = this.getIndicatorPeriod(condition, 20);
    return `${indicatorType}_${period}`;
  }

  /**
   * Validate inputs
   */
  private validateInputs(): void {
    if (!this.data || this.data.length === 0) {
      throw new Error('Market data is required for backtesting');
    }
    
    if (!this.strategy) {
      throw new Error('Strategy is required for backtesting');
    }
    
    if (this.strategy.riskManagement.initialCapital <= 0) {
      throw new Error('Initial capital must be greater than 0');
    }
    
    // Validate data integrity
    for (let i = 0; i < this.data.length; i++) {
      const bar = this.data[i];
      if (!bar.date || !bar.open || !bar.high || !bar.low || !bar.close) {
        throw new Error(`Invalid data at index ${i}: missing required fields`);
      }
      
      if (bar.high < bar.low || bar.close < bar.low || bar.close > bar.high || bar.open < bar.low || bar.open > bar.high) {
        throw new Error(`Invalid data at index ${i}: price relationships are incorrect`);
      }
    }
    
    // Debug: –ø—Ä–æ–≤–µ—Ä—è–µ–º –∏–Ω—Ç–µ—Ä–≤–∞–ª—ã –¥–∞–Ω–Ω—ã—Ö
    if (this.data.length >= 5) {
      const intervals = [];
      for (let i = 1; i < Math.min(10, this.data.length); i++) {
        const daysDiff = Math.floor((this.data[i].date.getTime() - this.data[i-1].date.getTime()) / (1000 * 60 * 60 * 24));
        intervals.push(daysDiff);
      }
      console.log(`üóìÔ∏è DATA INTERVALS (days between bars):`, intervals);
      console.log(`üìÖ First 5 dates:`, this.data.slice(0, 5).map(d => d.date.toISOString().split('T')[0]));
      
      const avgInterval = intervals.reduce((sum, val) => sum + val, 0) / intervals.length;
      console.log(`üìä Average interval: ${avgInterval.toFixed(1)} days`);
      
      if (avgInterval > 5) {
        console.warn(`‚ö†Ô∏è WARNING: Data appears to be weekly (avg ${avgInterval.toFixed(1)} days between bars)!`);
      }
    }
  }

  /**
   * Log IBS statistics for debugging
   */
  private logIBSStatistics(): void {
    const ibsValues = this.indicators.get('IBS');
    if (!ibsValues) return;

    const validIBS = ibsValues.filter(v => !isNaN(v));
    if (validIBS.length === 0) return;

    const lowThreshold = this.strategy.parameters.lowIBS || 0.1;
    const highThreshold = this.strategy.parameters.highIBS || 0.75;

    const belowLow = validIBS.filter(v => v < lowThreshold).length;
    const aboveHigh = validIBS.filter(v => v > highThreshold).length;
    const min = Math.min(...validIBS);
    const max = Math.max(...validIBS);
    const avg = validIBS.reduce((sum, v) => sum + v, 0) / validIBS.length;

    console.log(`üìä IBS STATISTICS:`);
    console.log(`   Range: ${min.toFixed(3)} - ${max.toFixed(3)}, Average: ${avg.toFixed(3)}`);
    console.log(`   Entry opportunities (IBS < ${lowThreshold}): ${belowLow}/${validIBS.length} (${(belowLow/validIBS.length*100).toFixed(1)}%)`);
    console.log(`   Exit opportunities (IBS > ${highThreshold}): ${aboveHigh}/${validIBS.length} (${(aboveHigh/validIBS.length*100).toFixed(1)}%)`);
    
    // –ü—Ä–æ–≤–µ—Ä–∏–º –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ—Å—Ç–∏
    let consecutiveHigh = 0;
    let maxConsecutiveHigh = 0;
    for (const ibs of validIBS) {
      if (ibs > highThreshold) {
        consecutiveHigh++;
        maxConsecutiveHigh = Math.max(maxConsecutiveHigh, consecutiveHigh);
      } else {
        consecutiveHigh = 0;
      }
    }
    console.log(`   Max consecutive days with IBS > ${highThreshold}: ${maxConsecutiveHigh}`);
  }

  /**
   * Generate chart data for visualization
   */
  private generateChartData(): any[] {
    return this.data.map((bar, index) => ({
      time: bar.date,
      date: bar.date,
      open: bar.open,
      high: bar.high,
      low: bar.low,
      close: bar.close,
      volume: bar.volume,
      equity: this.equity[index]?.value || this.strategy.riskManagement.initialCapital
    }));
  }

  /**
   * Calculate volatility at given index
   */
  private calculateVolatility(index: number): number {
    const period = Math.min(20, index + 1);
    const startIndex = Math.max(0, index - period + 1);
    
    const returns = [];
    for (let i = startIndex + 1; i <= index; i++) {
      const prevClose = this.data[i - 1].close;
      const currentClose = this.data[i].close;
      returns.push(Math.log(currentClose / prevClose));
    }
    
    if (returns.length === 0) return 0;
    
    const mean = returns.reduce((sum, r) => sum + r, 0) / returns.length;
    const variance = returns.reduce((sum, r) => sum + Math.pow(r - mean, 2), 0) / returns.length;
    
    return Math.sqrt(variance * 252); // Annualized volatility
  }

  /**
   * Get indicator values at given index
   */
  private getIndicatorValues(index: number): any {
    const values: any = {};
    
    for (const [name, data] of this.indicators) {
      if (data[index] !== undefined) {
        values[name] = data[index];
      }
    }
    
    return values;
  }

  /**
   * Calculate trend at given index
   */
  private calculateTrend(index: number): string {
    if (index < 10) return 'sideways';
    
    const currentPrice = this.data[index].close;
    const pastPrice = this.data[index - 10].close;
    
    if (currentPrice > pastPrice * 1.02) return 'up';
    if (currentPrice < pastPrice * 0.98) return 'down';
    return 'sideways';
  }

  /**
   * Calculate performance metrics using the dedicated metrics calculator
   */
  private calculatePerformanceMetrics(): PerformanceMetrics {
    const metricsCalculator = new MetricsCalculator(
      this.trades,
      this.equity,
      this.strategy.riskManagement.initialCapital,
      this.data // Use market data as benchmark for now
    );
    
    return metricsCalculator.calculateAllMetrics();
  }




}

/**
 * Simple backtest runner for the simplified app
 */
export async function runBacktest(data: OHLCData[], strategy: Strategy): Promise<BacktestResult> {
  console.log('Running backtest with strategy:', strategy.id, 'and', data.length, 'data points');
  
  // –ò—Å–ø–æ–ª—å–∑—É–µ–º —á–∏—Å—Ç—ã–π –±—ç–∫—Ç–µ—Å—Ç —Ç–æ–ª—å–∫–æ –¥–ª—è IBS —Å—Ç—Ä–∞—Ç–µ–≥–∏–∏
  const { CleanBacktestEngine } = await import('./clean-backtest');
  const engine = new CleanBacktestEngine(data, strategy);
  return engine.runBacktest();
}
